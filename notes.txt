In Http server the controller is responsible for handling HTTP requestand returning a response, but in microservice thecontroller is responsible for handling the messages and events.
so the controller in microservices is decorated by MesagePattern() or EventPattern(
)

1. Message Pattern:
  - Message Pattern is used for request response communication i.e. wen the message is sent to the microservices the controller listens for the message and returns a response.

2. Event Pattern:
  - Event attern used for the event based communication so when the messae is sent to the microservice the controller listens for the event and perform action but the controller cannot return any response back.


add users module in the gateway application
For Users microservice
use this command nest generate module users --project api-gateway 
use this command nest generate service users --project api-gateway 
use this command nest generate controller users --project api-gateway 

This command generates a new NestJS module named users inside the api-gateway project (usually used in a monorepo setup)

Similarly for all microservices i.e. auth, resume

To run the api gateway: use this command nest start api-gateway --watch

What we really want:
To forard the request to the microservices when request hits api-gateway. To do this you have to create the microservice client in the gateway

First issue: as we assume that the dto is same in api gateway and other microservices if changes in one microservice dto you have to make changes in api gateway dto. therefore define the dto in shared librarythat is used y the gateway and the microservice. what is the problem with this aproach. same dto used api gateway and the microservices means that every change to dto effects the gateway api contract and microservice appliation contract. create tight coupling

then if having common dto is not the solution then what is te solution?
The solution is to explicitly define the  microservice appliation contract and make them available to all application that want to use that microservice


contract is the set of rules  that define how to communicate with the microservice appliation. each microserviec define what message it can handle, what payload it expect and what data is return create a shared library using nest g library contrcts. those contract are created in shared library used by microservice application and the gateway. gateway dtowill stay as they are becaus ethere is no need to share themthey ae only use inside gateway

Organizing Code
Contract library dto is exactly the same in both api gateway and dto in microservice, but that is not always the case. lets imagine we want to expse only the resume id and title to client you can change the response model ie dto of api gateway.

if you share the same dto in api gateway and microservice application it create large coupling. This common dto is not he solution. The solution is to explicitly define the microsevice application contrat  and make them avalbel tro all application that ant to use that microservice.

Best Practice: Put Providers in libs/common, Not libs/contracts
ðŸ”´ libs/contracts â†’ should only contain DTOs, patterns, and symbols (contracts between microservices)
âœ… libs/common â†’ perfect for reusable services/providers like hashing



commands 

nest g app monorepo -> to create monorepo project
nest g app users 
nest g app resume
nest g app auth 

To install microservice in NestJS
npm i @nestjs/microservices

For communication from gateway to microservices
nest g module users --project api-gateway
nest g module resume --project api-gateway
nest g module auth --project api-gateway

nest g resource user --project users to create resource
nest g resource bilal --project api-gateway
nest g library contracts

gateway ke dto ka faida h age aik gateway s response me id title araha h books microservice me s or agr dosra gateway same books microservice use kre tou use sara books ka data dena h tou uss gateway ke dto me define krna hoga aik dto or uske hisaab s response denge .pipe(this.map())








passport-jwt use to implement jwt strategy
The @nestjs/jwt package (see more here) is a utility package that helps with JWT manipulation. 

// protect at the beginig from accessing the prtected route beaciuse re goe to one microservice then to other and then protetctwe donot wanna do taht

passport is responsible for attahing user object orpopulate the user object with the request boy

We have installed two authentication strategy packages.
There are two types of authentication strategies:

1. passport-local: Used for username and password authentication.
2. passport-jwt: Responsible for validating the JWT by extracting it from the Authorization header. It automatically checks if the token is valid or expired. If the JWT is invalid or expired, it will reject the request with a 403 Forbidden response. This means we donâ€™t need to write custom logic for token validation and expiration handling.




